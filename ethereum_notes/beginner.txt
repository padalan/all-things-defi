* Ethereum maintains bank accounts for its customers, both humans, and Code(contracts). Increment the balance of the recipient account, and decrement the balance of the originating account.

* List of accounts and their balances is known as the state. Every transaction thus can be seen as a state transition.

* Imagine contracts as lawyers who do paperwork for you.

* Amount of work taken to execute the contract is denoted in a quantity called Gas.

* Transaction represents a single session with the EVM.

* Gas analogies.
  Gas             ~   Fuel/Petrol/Oil
  Smart contract  ~   Engine
  Gas needed      ~   Mileage (operations dependent on the engine)
  Gas price/Fee   ~   Oil price based on the economy
  Gas limit       ~   Capacity of the fuel tank. Max amount of fuel that can be used.
  startGas        ~   There is enough fuel in the tank to reach the destination
  startGas in Ethereum White Paper. gasLimit in Ethereum Yellow Paper.
  remainingGas    ~   The fuel remaining after (Each operation or) reaching the destination.
  Block Gas Limit =   4,712,388 ~ 224 tx that each has a startGas of 21000.

* Storage costs Ether. If there is a step that clears an entry in the storage, the fee for executing that operation is waived, and a refund is given for freeing up storage space.

* Miners think about profit. If there is one transaction with start gas of 5 million, and another with 100 transactions with startGas of 50,000, miners are likely to prioritize a set of small transactions over a single transaction with very high startGas. This can lead to a delay of execution of a high startGas transaction.
 
* The transaction that runs out of gas is reverted, but still included in a block and the associated fee is paid to the miner.

* Originator must pay for all the fuel. Ether placed in escrow.
* Out of gas exception.

* Each account has a state associated with it and a 20-byte address.

* Unliked EOA contract accounts cannot initiate new transactions. Instead, contract accounts can only fire transactions in response to other transactions they have received from EOA or another contract account. An internal transaction is a transaction across contract accounts.

* codeHash: For contract accounts, codeHash is the code that gets hashed. For EOA it's the hash of an empty string.

* Begining from the root node of the tree, the key should tell you which child node to follow to get to the corresponding value, which is stored in the leaf nodes.

* In ethereum, the key-value mapping for the state tree is between address and their associated accounts, including the balance, nonce, codeHash, storageRoot. storageRoot is itself a tree.

* Every block has a 'Header' which stores the hash of the root node of three different Merkle trie structures including:
  1. State trie
  2. Transaction trie
  3. Receipts trie

* light nodes have access to block headers, which contain hashes of the three tries. They can still easily generate and receive verifiable answers about transactions, events, balances, etc.

* The benefit of Merkle Patricia tree is that the root node of this structure is cryptographically dependent on the data stored in the tree, and so that hash of the root node can be used as a secure identity for this data. Since the block header includes the root hash of the state, transaction, and receipts trees, any node can validate a small part of the state of Ethereum without needing to store the entire state, which can be potentially unbounded in size.

* Simply, a transaction is a cryptographically signed piece of instruction that is generated by an externally owned account, serialized, and then submitted to the blockchain.

* All transactions contain following fields:
  - nonce: a count of the number of transactions sent by the sender.
  - gasPrice: the number of Wei that the sender is willing to pay per unit of gas required to execute the transaction.
  - gasLimit: the Maximum upfront amount paid by the sender to execute the transaction.
  - to: the address of the recipient. During contract creation, the contract address does not exist yet. Hence an empty value is used.
  - value: the amount of wei to be transferred from the sender to the recipient. In the contract-creation transaction, this value serves as the starting balance within the newly created contract account.
  - v,r,s: used to generate the signature that identifies the sender of the transaction.
  - init: Only exists for a contract-creation transaction. When init is run, it returns the body of the account code, which is the piece of code that is permanently associated with the contract account.
  - date: Optional input data, only exists for message calls. Example, for the domain creation smart contract, a call to the contract might expect input fields such as the domain and IP address.

* Ommer block = uncle block = Orphaned blocks. Parent's parent and uncle's parent are equal.

* A block header is a portion of the block consisting of:

  - parentHash: the hash of the parent block's header
  - ommersHash: a hash of the current block's list of uncles
  - beneficiary: the account address that receives the mining fees.
  - *stateRoot: the hash of the root node of the state trie
  - *tractionRoot: the hash of the root node of the trie that contains all the transactions
  - *receiptsRoot: the hash of the root node of the trie that contains the receipts of all the transactions
  - logsBloom: a Bloom  filter (data structure) that consists of log information
  - difficulty: the difficulty level of this block
  - number: the count of the current block
  - gasLimit: the current gas limit per block
  - gasUsed: the sum of total gas used by transactions in this block
  - timestamp: the Unix timestamp of this block's inception
  - extraData: extra data related to this block
  - mixHash: the hash that, when combined with the nonce, proves that this block has carried out enough computation
  - nonce: the hash that, when combined with mixHash, proves that this block has carried out enough computation

* Intrinsic gas include:
  - A predefined cost of 21,000 gas
  - A storage fee of 4 gas for every byte of data or code that equals zero. 68 gas for a non-zero byte of data or code
  - Additional 32,000 gas for contract creation

* Contract creation: We first declare the address of the new account using a special formula.
* The code has the ability to read-write to its own internal storage (A database mapping 32-byte keys to 32-byte values), read the storage of the received message, and send messages to other contracts, trigger their execution in turn.
* Contracts interact with each other through an activity that is alternately called either "Calling" or "sending messages". A message is an object containing some quantity of ether, a byte-array of data of any size, the address of a sender and a recipient.


* Initialize the new contract account by:
  - Setting the nonce to zero
  - If the sender sent some Ether as a value with the transaction, set the account balance to that value
  - Deducting the value added to this new account from the sender's balance
  - setting the storage as empty
  - Setting the contract's codeHash as the hash of an empty string.

* A message call execution does not include any init code since no new accounts are created.
* Message call contains input data if the data was sent by the transaction sender.
* Message call contains output data, which is used if a subsequent execution needs this data.

* The size of each stack in the EVM is 256-bit, and the stack has a maximum size of 1024.
* EVM has a memory where items are stored as a word addressed byte arrays.
* EVM also has storage. Unlike memory, storage is non-volatile and is maintained as part of the system state.
* EVM stores contract code separately in virtual ROM.

* Pre-check for execution of a particular computation:
  - System state
  - remainingGas
  - Address of the account that owns the code that is executing
  - Address of the sender of the transaction that originated this execution
  - Address of the account that caused the code to execute.
  - gasPrice
  - Input Data
  - Value (in Wei) passed to this account
  - Machine code to be executed
  - Block header of the current block
  - The depth of the present message call or contract creation stack.

* The EVM executes the transaction recursively, computing the system state and the machine state for each loop.

--------------------------------------------
* When to use Blockchain:
  - Is the system defining digital relationships? Yes. Then, Account management offered by blockchain maybe appropriate.
  - Should data be dynamic and auditable? Yes. Blockchains record and store data updates.
  - Should data be managed by a Central Authority? No. Decentralization offered by blockchains can guarantee an immutable transaction history. But if Privacy is paramount, the public nature of transactions on the blockchain is too transparent.
  - Is the speed of the network important? No. blockchain provides consistency, speed not yet.
 
* Developer tools for dApp Development:
  - Parity: Ethereum client written in a low-level language Rust. Remember ParityWallet Hack?
  - Truffle: Development framework to create, compile, deploy, and test dApps.
  - EthPM: Package manager for Ethereum.
  - Oyente: Static analysis tool for snart contracts
  - Remix: in-browser editor and compiler.
  - Geth: Allows you to create and manage accounts via Javascript console. Public/private blockchains
  - Ganache: local private deveopment blockchain with prefunded accounts.
  - Metamask: Browser Wallet for Public/private blockchains.
  - SolC: cli solidity compiler
  - Mist: a Web3-enabled browser with wallet and contract development
  - web3.js: collection of JS libraries. Account management, Deploy, interact with deployed contracts.
  - IPFS: Iterplanetary file sharing system, and swarm are decentralized file storage solutions for web 3.0

* Geth:
  - Genesis.json file:

    {
      "config": {
          "chainId": 4839,  // Identifies the blockchain. Mainnet=1, Ropsten=3, Rinkeby=4, kovan=42
          "homesteadBlock": 0,
          "eip155Block": 0, // HomesteadBlock, eipblock155/8Block indicate to geth in which blocks the Protocol changes are introduced.
          "eip158Block": 0  
      },
    "alloc"       : {}, // Allows us to create addresses and fill the accounts with ether upon initializing the blockchain     
    "difficulty"  : "0x0400", // Indicates how difficult it will be to discover a valid has of the block.
    "extraData"   : "", // Optional 32 byte value where we can add extra data.
    "gasLimit"    : "0x7A1200", // Maxlimit of gas expenditure per block.
    "parentHash"  : "0x0000000000000000000000000000000000000000000000000000000000000000", // The keccak256 has of the parent block's header.
    "timestamp"   : "0x00"  // output of Unix time() function at the block's creation. 
   }
  
  - geth --datadir=./ethereum-test init genesis.json
  - geth --datadir=./ethereum-test  --networkid 12 console
  - geth console:
    > personal.newAccount()
    > eth.accounts
    > eth.getbalance(eth.accounts[0])
    > web3.fromWei(eth.getBalance(eth.accounts[0]), 'ether')

    > miner.start()
    > miner.stop()
  
    > eth.sendTransaction()

      {
        from: String - The address of the sending account. web3.eth.defaultAccount by default
        to: Strong - destination of the message. Left undefined for a contract-creation transaction.
        value: Number|string|BigNumber - The value transferred for the transaction in Wei. Also the endowment if it's a contract-creation transaction.
        gas: Number|string|BigNumber - The amount of gas to be used for this transaction
        gasPrice: Number|string|BigNumber - The price of this transaction in wei, defaults to the mean network gas price
        data: String - Either a big string containing the associated data of the message, or in case of a contract creation transaction, the initializaion code. 
        none: Number
      }
    > personal.unlockAccount(eth.accounts[0])
    > eth.sendTransaction({ to: eth.accounts[1], from eth.accounts[0], value: 100 })
    > eth.syncing
      {
        currentBlock: 14199,
        highestBlock: 3383246,
        knownStates: 35673,
        pulledStates: 23305,
        startingBlock: 0
      }
    > eth.getBlock(183)
      {
        difficulty: 2,
        extraData: "0xd783010600846765746887676f312e372e33856c696e75780000000000000000a445253076a272b7174b57861029c65c8db9c8c68afac4bf6b770110d50b22553b0e97067bc18df04d81b2e5b32a3fb9edc8be988417a874767f789ba1e5838700",
        gasLimit: 4712388,
        gasUsed: 0,
        hash: "0x377ff4ff28fff58fee51ed5dd199084c7bb078e7df0b02ee64ddaf6d07038831",
        logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        miner: "0x0000000000000000000000000000000000000000",
        mixHash: "0x0000000000000000000000000000000000000000000000000000000000000000",
        nonce: "0x0000000000000000",
        number: 183,
        parentHash: "0x913c6389389f118d37d0a846c37e3eaf3ea114819202078807b5bcfe01b39165",
        receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
        sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
        size: 607,
        stateRoot: "0x9853b6c62bd454466f4843b73e2f0bdd655a4e754c259d6cc0ad4e580d788f43",
        timestamp: 1492013189,
        totalDifficulty: 367,
        transactions: [],
        transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
        uncles: []
      }


    - On Rinkeby network, miner address is "0x000...000" and the nonce is also zeros. This is because the Rinkeby network does not run POW. It rus proof-of-authority running the Clique consensus protocol. A proof og authority network relies o trusted nodes designed as "signers" that have the ability to create blocks. A majority of signers on the network are required to validate the chain.

    > eth.getStorageAt("0x83a...fE7") - Deployed contract code.

* Proof of Authority:
  - POA is an easier way to run a blockchain with semi-trusted participants, such as consortium blockchain. 

----------------------------------------------------------------------------------------------------------------------------------

* Solidity Compilation: 

* echo var ballotStorage = `solc --combined-json abi,bin,interface ballot.sol` > ballot.js

geth --networkid 12 --datadir test-private-blockchain console
  > loadScript('ballot.js')
  > ballotStorage
  > var ABI = compiledStorage.contracts["ballot.sol:Ballot"].abi
  undefined
  > var bin = "0x" + compiledStorage.contracts["ballot.sol:Ballot"].bin
  undefined
  > var deploymentTX = {from: eth.accounts[0], data: bin, gas:1000000000000}
  undefined
  > var ballotInterface= eth.cotntract(JSON.parse(ABI))
  > var ballotInstance = ballotInterface.new(deploymentTx)
  > var address = eth.getTransactionReceipt(ballotInstance.transactionHash).contractAddress
  > address
  > var ballot = ballotInterface.at(address)
  > ballot.get.call()
  > ballot.set.sendTransaction(10, {from:eth.accounts[0], gas: 1000000000})
  > ballot.get.call()

